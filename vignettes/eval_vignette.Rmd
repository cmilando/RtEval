---
title: "Simple R(t) estimation evaluation comparison"
description: "An R(t) evaluation across multiple packages, fitting to simulated data, standardizing outputs, and evaluating outputs"
author: "Kaitlyn Johnson"
date: "2024-09-25"
output:
  bookdown::html_vignette2:
    fig_caption: yes
    code_folding: show
pkgdown:
  as_is: true
vignette: >
  %\VignetteIndexEntry{R(t) evaluation across packages: fit to simulated data with known reports}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Overview

The goal of this tutorial is to use multiple R(t) packages to fit to a simple, simulated outbreak
with a known R(t), serial interval, generation interval, and reporting delay probability mass function
(PMF). We will use the `summrt` package to generate standardized outputs, plot results, and 
quantitatively evaluate the accuracy in R(t) estimation.

Eventually we will expand this to additional vignettes that will fit to and evaluate more complex
simulated and real datasets (this might require not evaluating just accuracy and reliability
in R(t) but also nowcasting and forecasting expected observations and comparing to 
the true observations). 
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# install.packages('EpiEstim', repos = c('https://mrc-ide.r-universe.dev', 'https://cloud.r-project.org'))
# devtools::install_github("EpiForeSITE/summrt")

library(EpiNow2)
library(EpiEstim)
library(rtestim)
library(EpiLPS)
require(summRt)
library(ggplot2)
library (tidyverse)
library(epinowcast) # for add_pmf
```

## Load the simulated data

Load the dataset we will be fitting the R(t) estimation packages
to in this vignette.

This will eventually use data from the `rtdata` package that will be documented and
will describe the specific epidemiological use case this
data scenario is meant to represent. In this case, we are going to fit to data 
on the number of reported cases, with a known discrete generation interval probability
mass function (PMF) and reporting delay PMF that are also provided as data.

```{r load-rtdata}
# We will eventually replace this with package data specific to the dataset. 
# E.g. this might be our baseline infections, onset, report data
url <- "https://raw.githubusercontent.com/cmilando/RtEval/main/all_data.RDS"
all_data <- readRDS(url(url))

ggplot(all_data$rt) + 
  geom_line(aes(x = Day, y = Rt)) +
  geom_hline(aes(yintercept = 1), linetype = "dashed") + 
  xlab("Day") + ylab("R(t)") + 
  scale_y_continuous(trans = "log") + 
  theme_bw() + ggtitle("Simulated R(t)")

ggplot(all_data$generation) +
  geom_bar(aes(x = Day, y = Px), stat = "identity") + 
  xlab("Day") + ylab("Generation interval PMF") +
  theme_bw() 

ggplot(all_data$reporting_delay) +
  geom_bar(aes(x = Day, y = Px), stat = "identity") +
  xlab("Day") + ylab("Reporting delay PMF") +
  theme_bw()

ggplot(all_data$cases) +
  geom_bar(aes(x = day, y = daily_reports), stat = "identity") +
  xlab("Day") + ylab("Reported cases") + 
  theme_bw()
```


## Use each package to estimate R(t)

Fit each of the packages to the dataset. See the package specific vignettes for more
of a walk through for the decisions made for each package. 

```{r EpiNow2}

#EpiNow2
incidence_df = data.frame(
  date = lubridate::make_date(2020, 3, 19) + 1:nrow(all_data$cases),
  confirm = as.vector(all_data$cases$daily_reports)
)

gi_pmf <- NonParametric(pmf = all_data$serial$Px)
sym_report_delay_pmf <- NonParametric(pmf = all_data$reporting_delay$Px)
incubation_pmf <- NonParametric(pmf = all_data$incubation$Px)


res_epinow <- epinow(
  data = incidence_df,
  generation_time = generation_time_opts(gi_pmf),
  delays = delay_opts(incubation_pmf + sym_report_delay_pmf),
  backcalc = backcalc_opts(prior = 'reports'),
  rt = rt_opts(rw = 1),
  stan = stan_opts(chains = 4, cores = 4)
)

```

```{r EpiEstim}
# reporting data with dates indexed by integers starting at 0
incidence_df <- data.frame(
  dates = all_data$cases$day,
  I = as.vector(all_data$cases$daily_reports)
)
colnames(incidence_df) <- c('dates', 'I')

# Serial interval from data PMF-has leading 0 and is vector of probabilities
si_distr <- as.matrix(all_data$serial$Px)
if (all_data$serial$Day[1] == 1) si_distr <- c(0, si_distr)
si_distr

# Estimate R DAILY
res_epiestim <- EpiEstim::estimate_R(
  incid = incidence_df,
  method = "non_parametric_si",
  config = make_config(list(
    si_distr = si_distr,
    t_start = 2:nrow(incidence_df),
    t_end = 2:nrow(incidence_df)
  )),
  backimputation_window = 10
)

```

```{r rtestim}
res_rtestim <- cv_estimate_rt(
  observed_counts = all_data$cases$daily_reports[rr],
  x = all_data$cases$day[rr],
  delay_distn = all_data$serial$Px
)

```

```{r EpiLPS}
# discrete dist
si_spec <- Idist(probs = all_data$serial$Px)

# incidence
incidence = all_data$cases$daily_reports
which(is.na(incidence))
incidence[1] <- 0

#
res_EpiLPS <- estimR(incidence = incidence, si = si_spec$pvec)

```

# Call the `SummRt` package to standardize the outputs 
```{r get-standardized-outputs}
# EpiNow2
EpiNow2_summrt <- summarize_rtestimate(res_epinow)

# EpiEstim
EpiEstim_summrt <- summarize_rtestimate(res_epiestim)

# rtestim
Rtestim_summrt <- summarize_rtestimate(res_rtestim)

# EpiLPS
EpiLPS_summrt <- summarize_rtestimate(res_EpiLPS)

```

# Plot the results from each method

```{r plot-outputs}
#source file with this_plot(), later will call function


# EpiNow2
plot_epinow <- this_plot(pd=plot_data_epinow,
                         title="EpiNow2",
                         rt_sim=all_data$rt)

# EpiEstim
plot_epiestim <- this_plot(pd = EpiEstim_summrt, 
                          title = "EpiEstim",
                         rt_sim=all_data$rt)

# Rtestim
plot_rtestim <- this_plot(pd = Rtestim_summrt, 
                          title = "Rtestim",
                         rt_sim=all_data$rt)

# EpiLPS
plot_EpiLPS <- this_plot(pd = EpiLPS_summrt, 
                          title = "EpiLPS",
                         rt_sim=all_data$rt)

```

## Score the output of the R(t) model
This will either be compared to ground truth simulated data or
observations 
```{r score-output}
```

## Compare scores from each package
Visual comparison of scores for each package
```{r compare-scores-across-packages}
```

## Discussion/Interpretation
Which packages perform best on this dataset in what regimes? 
E.g. EpiEstim most accurately captures perturbation,
EpiNow2 performs best at nowcasting/forecasting observations
